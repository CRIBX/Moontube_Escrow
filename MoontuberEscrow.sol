// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "./EscrowIndividual.sol";

/**
 * @title MoontuberEscrow
 * @dev Escrow contract to facilitate payments between customers and Moontuber partners with support for ETH, supported stablecoins, and other ERC20 tokens.
 * Includes timelock functionality for contract upgrades to enhance decentralization.
 */
contract MoontuberEscrow is Initializable, AccessControlUpgradeable, ReentrancyGuardUpgradeable, UUPSUpgradeable {
    using SafeERC20 for IERC20;

    /// @notice Role identifier for administrative actions
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    
    /// @notice Role identifier for escrow-specific actions
    bytes32 public constant ESCROW_ROLE = keccak256("ESCROW_ROLE");
    
    /// @notice Role identifier for upgrade actions through timelock
    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER_ROLE");

    /// @notice Dead address constant for validation checks
    address constant DEAD_ADDRESS = 0x000000000000000000000000000000000000dEaD;

    /// @notice Timelock controller contract for managing upgrade operations
    TimelockControllerUpgradeable public timelock;

    /// @notice Wallet address where commission fees are sent
    address payable public commissionWallet;

    /// @notice Developer fee percentage (in basis points, i.e., 200 = 2%)
    uint256 public devFee;

    /// @notice Commission rate for Moontubers (e.g., 10 = 10%)
    uint256 public defaultCommissionRate;

    /// @notice Processing fee percentage for refunds (e.g., 2 = 2%)
    uint256 public defaultProcessingFeePercent;

    /// @notice Maps Moontuber addresses to their commission rates
    mapping(address => uint256) public moontuberCommissionRates;

    /// @notice Supported stablecoins for payments
    mapping(address => bool) public supportedTokens;

    /// @notice Maps an address to a list of escrow addresses
    mapping(address => address[]) public escrows;

    /// @notice Wallet address where commission token fees are sent
    address payable public commissionTokenWallet;

    /// @notice Stores details of a scheduled upgrade operation.
    struct ScheduledUpgrade {
        /// @notice The new implementation address.
        address newImplementation;
        /// @notice The timestamp after which the upgrade can be executed.
        uint256 executeTime;
        /// @notice The operation ID hash generated by the timelock.
        bytes32 operationId;
        /// @notice Flag indicating if there is an active scheduled upgrade.
        bool active;
    }

    ScheduledUpgrade public scheduledUpgrade;

    /// @notice Event emitted when a deposit is made
    event DepositMade(address escrowAddress, address customer, uint256 index);

    /// @notice Event emitted when the developer fee is updated
    event DevFeeUpdated(uint256 newDevFee);

    /// @notice Event emitted when a Moontuber's commission rate is changed
    event CommissionRateUpdated(address moontuber, uint256 newRate);

    /// @notice Event emitted when a new stablecoin is added
    event StablecoinAdded(address token);

    /// @notice Event emitted when a stablecoin is removed
    event StablecoinRemoved(address token);

    /// @notice Event emitted when funds are released to a Moontuber
    event FundsReleased(address escrowAddress, address moontuber);

    /// @notice Event emitted when a refund is processed for a customer
    event RefundProcessed(address escrowAddress, address customer);

    /// @notice Event emitted when default commission rate is updated
    event DefaultCommissionRateUpdated(uint256 newDefaultCommissionRate);

    /// @notice Event emitted when default processing fee percentage is updated
    event DefaultProcessingFeePercentUpdated(uint256 newDefaultProcessingFeePercent);

    /// @notice Event emitted when an upgrade is scheduled through timelock
    event UpgradeScheduled(address newImplementation, uint256 executeTime);

    /// @notice Event emitted when a scheduled upgrade is cancelled
    event UpgradeCancelled(address newImplementation);

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    /**
     * @notice Initializes the contract with the commission wallet address and timelock controller.
     * @param _commissionWallet Address of the wallet to receive commission fees
     * @param _commissionTokenWallet Address of the wallet to receive commission token fees
     * @param _defaultCommissionRate Default commission rate for Moontubers
     * @param _defaultProcessingFeePercent Default processing fee percentage
     */
    function initialize(
        address payable _commissionWallet,
        address payable _commissionTokenWallet,
        uint256 _defaultCommissionRate,
        uint256 _defaultProcessingFeePercent
    ) public initializer {
        __AccessControl_init();
        __ReentrancyGuard_init();
        __UUPSUpgradeable_init();

        // Initialize timelock with proposer and executor as msg.sender
        address[] memory proposers = new address[](1);
        address[] memory executors = new address[](1);
        proposers[0] = msg.sender;
        executors[0] = msg.sender;

        timelock = new TimelockControllerUpgradeable();
        timelock.initialize(2 days, proposers, executors, msg.sender);

        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ADMIN_ROLE, msg.sender);
        _grantRole(UPGRADER_ROLE, address(timelock));

        commissionWallet = _commissionWallet;
        commissionTokenWallet = _commissionTokenWallet;
        devFee = 200; // Initializing devFee to 2%
        defaultCommissionRate = _defaultCommissionRate;
        defaultProcessingFeePercent = _defaultProcessingFeePercent;
    }

    /**
     * @dev Internal function to authorize contract upgrades.
     * Only allows upgrades through the timelock controller.
     */
    function _authorizeUpgrade(address /* newImplementation */) internal view override {
        require(hasRole(UPGRADER_ROLE, msg.sender));
    }

    /**
    * @notice Schedules an upgrade to a new implementation contract through the timelock
    * @param newImplementation Address of the new implementation contract
    */
    function scheduleUpgrade(address newImplementation) external onlyRole(ADMIN_ROLE) {
        require(newImplementation != address(0));

        bytes memory data = abi.encodeWithSelector(
            this.upgradeToAndCall.selector,
            newImplementation,
            ""
        );

        bytes32 id = timelock.hashOperation(
            address(this),
            0,
            data,
            bytes32(0),
            bytes32(0)
        );

        timelock.schedule(
            address(this),
            0,
            data,
            bytes32(0),
            bytes32(0),
            2 days
        );

        scheduledUpgrade.newImplementation = newImplementation;
        scheduledUpgrade.executeTime = block.timestamp + 2 days;
        scheduledUpgrade.operationId = id;
        scheduledUpgrade.active = true;

        emit UpgradeScheduled(newImplementation, scheduledUpgrade.executeTime);
    }

    /**
    * @notice Cancels a scheduled upgrade
    * @param newImplementation Address of the new implementation contract
    */
    function cancelUpgrade(address newImplementation) external onlyRole(ADMIN_ROLE) {
        require(scheduledUpgrade.active);
        require(scheduledUpgrade.newImplementation == newImplementation);

        timelock.cancel(scheduledUpgrade.operationId);
        scheduledUpgrade.active = false;

        emit UpgradeCancelled(newImplementation);
    }

    /**
    * @notice Executes the scheduled upgrade after the timelock delay has passed.
    */
    function executeScheduledUpgrade() external onlyRole(ADMIN_ROLE) {
        require(scheduledUpgrade.active);
        require(block.timestamp >= scheduledUpgrade.executeTime);

        bytes memory data = abi.encodeWithSelector(
            this.upgradeToAndCall.selector,
            scheduledUpgrade.newImplementation,
            ""
        );

        timelock.execute(
            address(this),
            0,
            data,
            bytes32(0),
            bytes32(0)
        );

        scheduledUpgrade.active = false;
    }

    /**
    * @notice Returns whether there is an active scheduled upgrade and the time remaining until it can be executed.
    * @return active A boolean indicating if there is an active scheduled upgrade.
    * @return timeRemaining The number of seconds remaining until the scheduled upgrade can be executed, or 0 if it's already executable or not scheduled.
    */
    function getScheduledUpgradeInfo() external view returns (bool active, uint256 timeRemaining) {
        active = scheduledUpgrade.active;
        if (!active) {
            return (false, 0);
        }
        if (block.timestamp >= scheduledUpgrade.executeTime) {
            return (true, 0);
        }
        return (true, scheduledUpgrade.executeTime - block.timestamp);
    }

    /**
     * @notice Deposits funds into an escrow.
     * @param moontuber Address of the Moontuber 
     * @param primaryAssetType Primary asset type ("ETH" or "ERC20")
     * @param primaryAssetAddress Address of the ERC20 token (zero address for ETH)
     * @param primaryAmount Amount to be deposited of primary asset type
     * @param additionalAssetAddresses Array of additional ERC20 token addresses
     * @param additionalAmounts Array of amounts to be deposited for each additional asset
     */
    function deposit(
        address moontuber,
        string memory primaryAssetType,
        address primaryAssetAddress,
        uint256 primaryAmount,
        address[] memory additionalAssetAddresses,
        uint256[] memory additionalAmounts
    ) external payable nonReentrant {
        require(moontuber != address(0));
        require(additionalAssetAddresses.length == additionalAmounts.length);
        require(primaryAmount > 0);
        require(additionalAssetAddresses.length <= 10);

        uint256 totalETHDeposited = msg.value;
        uint256 serviceFee = (primaryAmount * devFee) / 10000; // devFee is in basis points (e.g., 200 = 2%)
        uint256 totalPrimaryAmount = primaryAmount + serviceFee;

        if (keccak256(abi.encodePacked(primaryAssetType)) == keccak256(abi.encodePacked("ETH"))) {
            require(primaryAssetAddress == address(0));
            require(totalETHDeposited >= totalPrimaryAmount);

            (bool feeTransferSuccess, ) = commissionWallet.call{value: serviceFee}("");
            require(feeTransferSuccess);
            totalETHDeposited = totalETHDeposited - serviceFee;

            uint256 excess = totalETHDeposited - totalPrimaryAmount;
            if (excess > 0) {
                (bool refundSuccess, ) = payable(msg.sender).call{value: excess}("");
                require(refundSuccess);
            }
        } else {
            require(supportedTokens[primaryAssetAddress]);
            IERC20(primaryAssetAddress).safeTransferFrom(msg.sender, commissionWallet, serviceFee);
        }

        EscrowIndividual newEscrow;
        try new EscrowIndividual{value: totalETHDeposited}(
            address(this),
            msg.sender,
            commissionWallet,
            commissionTokenWallet,
            devFee,
            moontuber,
            primaryAssetType,
            primaryAssetAddress,
            primaryAmount,
            additionalAssetAddresses,
            additionalAmounts
        ) returns (EscrowIndividual escrow) {
            newEscrow = escrow;
        } catch Error(string memory reason) {
            revert(string(abi.encodePacked(reason)));
        } catch {
            revert();
        }

        if (keccak256(abi.encodePacked(primaryAssetType)) != keccak256(abi.encodePacked("ETH"))) {
            IERC20(primaryAssetAddress).safeTransferFrom(msg.sender, address(newEscrow), primaryAmount);
        }

        for (uint256 i = 0; i < additionalAssetAddresses.length; i++) {
            if (additionalAssetAddresses[i] != address(0) && additionalAmounts[i] > 0) {
                serviceFee = (additionalAmounts[i] * devFee) / 10000;
                // Transfer service fee to commissionTokenWallet
                IERC20(additionalAssetAddresses[i]).safeTransferFrom(msg.sender, commissionTokenWallet, serviceFee);
                // Transfer additional amount to new escrow
                IERC20(additionalAssetAddresses[i]).safeTransferFrom(msg.sender, address(newEscrow), additionalAmounts[i]);
            }
        }

        escrows[moontuber].push(address(newEscrow));
        uint256 index = escrows[moontuber].length - 1;
        _grantRole(ESCROW_ROLE, address(newEscrow));
        emit DepositMade(address(newEscrow), moontuber, index);
    }

    /**
     * @notice Releases funds to the Moontuber after service completion.
     * @param moontuber Address of the moontuber
     * @param index Index of the escrow in customer's list
     */
    function releaseFunds(address moontuber, uint256 index) external onlyRole(ADMIN_ROLE) nonReentrant {
        require(index < escrows[moontuber].length);
        address escrowAddress = escrows[moontuber][index];
        require(hasRole(ESCROW_ROLE, escrowAddress));
        EscrowIndividual(payable(escrowAddress)).releaseFunds();
        _revokeRole(ESCROW_ROLE, escrowAddress);
        emit FundsReleased(escrowAddress, moontuber);
    }

    /**
     * @notice Processes a refund for the customer.
     * @param moontuber Address of the moontuber
     * @param index Index of the escrow in moontuber's list
     */
    function processRefund(address moontuber, uint256 index) external onlyRole(ADMIN_ROLE) nonReentrant {
        require(index < escrows[moontuber].length);
        address escrowAddress = escrows[moontuber][index];
        require(hasRole(ESCROW_ROLE, escrowAddress));
        EscrowIndividual(payable(escrowAddress)).processRefund();
        _revokeRole(ESCROW_ROLE, escrowAddress);
        emit RefundProcessed(escrowAddress, moontuber);
    }

    /**
     * @notice Updates the developer fee percentage.
     * @param _newDevFee New developer fee percentage (in percentage, 0-5)
     */
    function updateDevFee(uint256 _newDevFee) external onlyRole(ADMIN_ROLE) {
        require(_newDevFee >= 0 && _newDevFee <= 5);
        devFee = _newDevFee * 100; // Convert to basis points
        emit DevFeeUpdated(_newDevFee);
    }

    /**
     * @notice Updates the commission rate for a specific Moontuber.
     * @param _moontuber Address of the Moontuber
     * @param _newRate New commission rate (must <= 15%)
     */
    function updateMoontuberCommissionRate(address _moontuber, uint256 _newRate) external onlyRole(ADMIN_ROLE) {
        require(_moontuber != address(0));
        require(_moontuber != DEAD_ADDRESS);
        require(_newRate <= 15);
        moontuberCommissionRates[_moontuber] = _newRate;
        emit CommissionRateUpdated(_moontuber, _newRate);
    }

    /**
     * @notice Adds a new supported stablecoin for deposits.
     * @param _tokenAddress Address of the ERC20 token contract
     */
    function addStablecoin(address _tokenAddress) external onlyRole(ADMIN_ROLE) {
        require(_tokenAddress != address(0));
        require(!supportedTokens[_tokenAddress]);
        supportedTokens[_tokenAddress] = true;
        emit StablecoinAdded(_tokenAddress);
    }

    /**
     * @notice Removes a supported stablecoin from the list.
     * @param _tokenAddress Address of the ERC20 token contract
     */
    function removeStablecoin(address _tokenAddress) external onlyRole(ADMIN_ROLE) {
        require(supportedTokens[_tokenAddress]);
        supportedTokens[_tokenAddress] = false;
        emit StablecoinRemoved(_tokenAddress);
    }

    /**
     * @notice Retrieves an escrow record for a specific Moontuber.
     * @param customer Address of the customer
     * @param index Index of the escrow in customer's list
     * @return Address of the EscrowIndividual contract
     */
    function getEscrow(address customer, uint256 index) external view returns (address) {
        require(index < escrows[customer].length);
        return escrows[customer][index];
    }

    /**
     * @notice Sets the default commission rate for Moontubers.
     * @param _newDefaultCommissionRate New default commission rate (in percentage)
     */
    function setDefaultCommissionRate(uint256 _newDefaultCommissionRate) external onlyRole(ADMIN_ROLE) {
        require(_newDefaultCommissionRate <= 15);
        defaultCommissionRate = _newDefaultCommissionRate;
        emit DefaultCommissionRateUpdated(_newDefaultCommissionRate);
    }

    /**
     * @notice Sets the default processing fee percentage.
     * @param _newDefaultProcessingFeePercent New default processing fee percentage
     */
    function setDefaultProcessingFeePercent(uint256 _newDefaultProcessingFeePercent) external onlyRole(ADMIN_ROLE) {
        require(_newDefaultProcessingFeePercent <= 15);
        defaultProcessingFeePercent = _newDefaultProcessingFeePercent;
        emit DefaultProcessingFeePercentUpdated(_newDefaultProcessingFeePercent);
    }

    /**
     * @dev Fallback function to receive ETH
     */
    receive() external payable {}
}